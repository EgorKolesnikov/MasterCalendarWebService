## Либы

cppCMS

mongoDB 3.6. Install: https://docs.mongodb.com/v3.6/tutorial/install-mongodb-enterprise-on-ubuntu/

mongocxx 3.3.0. Install: http://mongocxx.org/mongocxx-v3/installation/

## Что где лежит

### src/
1) util.h/.cpp - вспомогательные функции
2) urls.h/.cpp - реализация поведения ручек
3) server.cpp - main

### run/
1) server.sh - сборка и запуск сервера. Указывается необходимый протокол: http или fastcgi
2) configs/ - кофиги сервера на разных протоколах

### test/
1) get/ - генерация и запуск нагрузочного тестирования с ammo только GET запросов
2) post/ - генерация и запуск нагрузочного тестирования с ammo только POST запросов
3) [not done] mixed/ - генерация и запуск нагрузочного тестирования с ammo GET и POST запросов вместе
4) tank.sh - запуск нагрузочного тестирования указанного типа (get|post|mixed)

Тестирование поведения ручек реализовано в test/api.py (проверки на формат JSON, формат даты, возвращаемые коды и т.д.)


## Нагрузочное тестирование

Конфигурация сервера при использовании HTTP протокола:
```
{
    "service" : {
        "api" : "http",
        "port" : 8081,
        "worker_processes": 2,
        "worker_threads": 2,
        "mod": "thread",
    },
    "logging" : {  
       "level" : "error",
       "stderr": true,
    },
}

```

Как описани здесь (http://cppcms.com/wikipp/en/page/ref_config#server-mod) mod "thread" запускает инстансы приложения в пуле. Позволяет достичь наилучшего результата, но краш системы убийственен - убивается сразу всё.

### GET

### POST

### GET + POST
Сначала база заполнялась 100000 рандомными встречами (длиной в 1 день, на протяжении в 20 лет, день выбирался рандомно).

Картина реального мира, в котором используется этот сервис, предполагает, что GET запросов больше, чем POST. Т.е. например какие-то организации постят события, а обычные люди просматривают и узнают, какие события будут в ближайшее время или в интервал времени в будущем. Так, ожидается, что количество GET не в десятки раз больше POST, максимум в 5-7 раз.

Файл патронов составлялся генератором из mixed/generator.py. Генерировалось 100000 запросов с конфигурацией:
1) Вероятность POST запроса 20%
2) Из 80% GET запросов: получение одного объекта - 80%, получение списка объектов - 20.
3) Список объектов запрашивался за рандомный один год.

#### Не ограничиваем длину запроса
Сначала попробуем протестировать без ограничения на количество объектов, когда делается GET запрос на выгрузку списка событий за год. Несколько секунд для line(100, 5000, 10m) достаточно, чтобы понять, что всё плохо: https://overload.yandex.net/129513

Все события генерировались в пределах 20 лет. Т.е. примерно 100000 / 20 = 50000 событий было в каждом году изначально, до запуска тестирования. Это уже достаточно много для одно выгрузки. Плюс во время нагрузочного тестирования создаются новые встречи, что увеличивает размер возвращаемых данных.

#### Ограничим длину выдачи
Так как мы не держим даже 200rps, то было решено изменить логику выдачи списка событий: зачем пользователям видеть так много событий? Все 50000 за раз они проанализировать всё равно не смогут. И кажется, что события слишком далеко в будущее очень редко захочится смотреть. 20 лет примерно 7000 дней, т.е. 1000 недель, т.е. примерно 100 событий в неделю инициализированно (до нагрузочного тестирования).

Будем разрешать пользователю указывать начальную дату выгрузки (может быть пустой), начиная от которой будет выгружаться 100 ближайших событий.

Можно конечно подумать про страничную выдачу событий, где очевидно возникают проблемы с консистентностью выдачи. Но в версии нашего календаря v1.0 возложим эту ответственность на пользователя: пускай со своей стороны разбивает запрос на дни/недели, если ему нужно очень много данных.

#### Результаты с ограничением длины списка выдачи
Оценим первоначально, что мы можем выдержать. Проведём тестирование на line(100, 5000, 4m): https://overload.yandex.net/129551
По response time distribution видим, что в районе 2000 rps начинаются серьёзные проблемы. Примерно в этих же пределах CPU начинает зашваливать. Возьмём с запасом и будем утверждать, что наш сервис умеет держать нагрузку в 1800 rps. Проведёт тестирование line(100, 1800, 4m), const(1800, 5m): 
