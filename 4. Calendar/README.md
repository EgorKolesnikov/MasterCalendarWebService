## Либы

cppCMS

mongoDB 3.6. Install: https://docs.mongodb.com/v3.6/tutorial/install-mongodb-enterprise-on-ubuntu/

mongocxx 3.3.0. Install: http://mongocxx.org/mongocxx-v3/installation/

## Что где лежит

### src/
1) util.h/.cpp - вспомогательные функции
2) urls.h/.cpp - реализация поведения ручек
3) server.cpp - main

### run/
1) server.sh - сборка и запуск сервера. Указывается необходимый протокол: http или fastcgi
2) configs/ - кофиги сервера на разных протоколах

### test/
1) get/ - генерация и запуск нагрузочного тестирования с ammo только GET запросов
2) post/ - генерация и запуск нагрузочного тестирования с ammo только POST запросов
3) [not done] mixed/ - генерация и запуск нагрузочного тестирования с ammo GET и POST запросов вместе
4) tank.sh - запуск нагрузочного тестирования указанного типа (get|post|mixed)

Тестирование поведения ручек реализовано в test/api.py (проверки на формат JSON, формат даты, возвращаемые коды и т.д.)


## Нагрузочное тестирование

Конфигурация сервера при использовании HTTP протокола:
```
{
    "service" : {
        "api" : "http",
        "port" : 8081,
        "worker_processes": 2,
        "worker_threads": 2,
        "mod": "thread",
    },
    "logging" : {  
       "level" : "error",
       "stderr": true,
    },
}

```

Как описани здесь (http://cppcms.com/wikipp/en/page/ref_config#server-mod) mod "thread" запускает инстансы приложения в пуле. Позволяет достичь наилучшего результата, но краш системы убийственен - убивается сразу всё.

### GET и POST отдельно
1) GET: https://overload.yandex.net/129601 line(100, 7000, 5m). В пределах 3600-3800 начинаем перегружаться. Проверим на 3800: https://overload.yandex.net/129607. Всё в целом стабильно, кроме одного пика, после которого всё достаточно ровно и без проблем.
2) POST: 

### GET + POST
Сначала база заполнялась 100000 рандомными встречами (длиной в 1 день, на протяжении в 20 лет, день выбирался рандомно).

Картина реального мира, в котором используется этот сервис, предполагает, что GET запросов больше, чем POST. Т.е. например какие-то организации постят события, а обычные люди просматривают и узнают, какие события будут в ближайшее время или в интервал времени в будущем. Так, ожидается, что количество GET не в десятки раз больше POST, максимум в 5-7 раз.

Файл патронов составлялся генератором из mixed/generator.py. Генерировалось 100000 запросов с конфигурацией:
1) Вероятность POST запроса 20%
2) Из 80% GET запросов: получение одного объекта - 80%, получение списка объектов - 20.
3) Список объектов запрашивался за рандомный один год.

#### Ограничение на длину выдачи
Будем разрешать пользователю указывать начальную дату выгрузки (может быть пустой), начиная от которой будет выгружаться 200 ближайших событий.

Можно конечно подумать про страничную выдачу событий, где очевидно возникают проблемы с консистентностью выдачи. Но в версии нашего календаря v1.0 возложим эту ответственность на пользователя: пускай со своей стороны разбивает запрос на дни/недели, если ему нужно очень много данных.

#### Результаты
Оценим первоначально, что мы можем выдержать. Проведём тестирование на line(100, 5000, 5m): https://overload.yandex.net/129460
По response time distribution видим, что в районе 1300 rps начинаются проблемы. Примерно в этих же пределах CPU начинает зашкаливать. Возьмём с запасом и будем утверждать, что наш сервис умеет держать нагрузку в 1000 rps. Действительно, 1000 держит достаточно хорошо (https://overload.yandex.net/129584). Хорошо в плане response time distribution - не самое равноерное распределение, но верхняя и нижняя граница времени ответа находятся в приемлемых пределах. А 1200 уже не очень (https://overload.yandex.net/129599) и квантиль очень быстро и сильно скачит, и response time distribution очень сильно разбросано. В обоих случаях упираемся с CPU

### Вывод
Разработанная версия календаря способна выдержать нагрузку в 1000-1100 rps на "реальных" запросах. Конечно, нужно понимать, что тестирование проводилось не на настоящем сервере, а на ноутбуке. Конечно, в сравнение с hello-world где только один возможный запрос и нет взаимодействий с базой - даже рядом не стоит. Но нужно понимать, что тестирование проводилось на ноутбуке, а не на настоящем сервере. Нужно было, чтобы были воркеры и для соединения с базой и для приёма запросов.

Нагрузочное тестировани сложно сэмулировать как будто это 1000 разных пользователей со всех концов мира приходят к нам в календарь. Учитывая это, можно предположить, что в реальном мире всё может стать хуже (хотя ожидается, что не на много).

