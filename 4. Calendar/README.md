## Либы

cppCMS

mongoDB 3.6. Install: https://docs.mongodb.com/v3.6/tutorial/install-mongodb-enterprise-on-ubuntu/

mongocxx 3.3.0. Install: http://mongocxx.org/mongocxx-v3/installation/

## Что где лежит

### src/
1) util.h/.cpp - вспомогательные функции
2) urls.h/.cpp - реализация поведения ручек
3) server.cpp - main

### run/
1) server.sh - сборка и запуск сервера. Указывается необходимый протокол: http или fastcgi
2) configs/ - кофиги сервера на разных протоколах

### test/
1) get/ - генерация и запуск нагрузочного тестирования с ammo только GET запросов
2) post/ - генерация и запуск нагрузочного тестирования с ammo только POST запросов
3) [not done] mixed/ - генерация и запуск нагрузочного тестирования с ammo GET и POST запросов вместе
4) tank.sh - запуск нагрузочного тестирования указанного типа (get|post|mixed)

Тестирование поведения ручек реализовано в test/api.py (проверки на формат JSON, формат даты, возвращаемые коды и т.д.)


## Нагрузочное тестирование

Конфигурация сервера при использовании HTTP протокола:
```
{
    "service" : {
        "api" : "http",
        "port" : 8081,
        "worker_processes": 2,
        "worker_threads": 2,
        "mod": "thread",
    },
    "logging" : {  
       "level" : "error",
       "stderr": true,
    },
}

```

Как описани здесь (http://cppcms.com/wikipp/en/page/ref_config#server-mod) mod "thread" запускает инстансы приложения в пуле. Позволяет достичь наилучшего результата, но краш системы убийственен - убивается сразу всё.

В моём случае, POST запросы выполнялиь гораздо лучше GET запросов.

1) Для тестирования GET запросов из базы доставались известные uid объектов. Для каждого формировался свой url и все составленные урлы разбавлялись выгрузкой всей коллекции (т.е. здесь и отдельные GET и GET сразу на всю коллекцию). https://overload.yandex.net/129044 На графиках Quantile и Response time destribution видно, что всё хорошо только до rps = ~800. График CPU показывает, что упираемся именно в него. Действительно, держимся достаточно стабильно при rps=750: https://overload.yandex.net/129047 (ответ в районе 100-150 ms).
2) POST, 500-5000, 3m: https://overload.yandex.net/1290. Единственный непонятный пик, которым на фоне остальных запросов можно, думаю, пренебречь. По графику CPU видно, что всё ближе и ближе к пределу. Попробуем запустить 3000-10000, 2m: https://overload.yandex.net/129057. По графикам Quantiles И Response time destribution видно, что резкий рост (не смотря на пики), начинается в районе 6000. Опять же, график CPU показывает что на 6000 как раз упираемся в предел. Посмотрим на const(5500, 5m): https://overload.yandex.net/129059 Response time distribution не слишком стабилен, но колебания в пределах нормы. Quantils показывает, что время обработки (максимальное) примерно 50-70 ms, что для POST достаточно неплохо при такой нагрузке.
